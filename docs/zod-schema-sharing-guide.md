# Zod Schema Sharing Guide

SwallowKit's core feature is **Zod Schema Sharing**, which enables type-safe, validated data flow across your entire stack‚Äîfrom frontend forms to backend APIs to database storage.

> **Note**: This guide explains the concepts and benefits of Zod schema sharing. For practical implementation with SwallowKit's code generation, see the **[Scaffold Guide](./scaffold-guide.md)**.

## Why Zod Schema Sharing?

### The Problem

In traditional full-stack development, you often define types and validation logic multiple times:

- **Frontend**: Form validation with one library
- **Backend API**: Request validation with another library
- **Database**: Schema definitions in ORM or separate files
- **TypeScript Types**: Manually maintained interfaces

This leads to:
- ‚ùå Code duplication
- ‚ùå Inconsistent validation
- ‚ùå Type drift between layers
- ‚ùå Maintenance overhead

### The SwallowKit Solution

Define your schema **once** with Zod, and use it everywhere:

```typescript
// lib/schemas/user.ts - Single Source of Truth
import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email'),
  age: z.number().min(18, 'Must be 18 or older'),
});

export type User = z.infer<typeof UserSchema>;
```

This single schema provides:
- ‚úÖ TypeScript types (`User`)
- ‚úÖ Runtime validation
- ‚úÖ Error messages
- ‚úÖ Transform functions
- ‚úÖ Default values

üí° **Ready to use this in practice?** See how SwallowKit automatically generates CRUD operations from Zod schemas in the **[Scaffold Guide](./scaffold-guide.md)**.

## Usage Across Layers

### Layer 1: Client-Side Validation

Use the same schema in your React components for immediate user feedback:

```typescript
// components/UserForm.tsx
'use client'

import { UserSchema } from '@/lib/schemas/user';
import { createUserAction } from '@/app/actions';
import { useState } from 'react';

export function UserForm() {
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const handleSubmit = async (formData: FormData) => {
    // Client-side validation
    const result = UserSchema.safeParse({
      id: crypto.randomUUID(),
      name: formData.get('name'),
      email: formData.get('email'),
      age: Number(formData.get('age')),
    });
    
    if (!result.success) {
      // Display Zod errors to user
      const fieldErrors: Record<string, string> = {};
      result.error.errors.forEach((err) => {
        if (err.path[0]) {
          fieldErrors[err.path[0] as string] = err.message;
        }
      });
      setErrors(fieldErrors);
      return;
    }
    
    setErrors({});
    await createUserAction(formData);
  };
  
  return (
    <form action={handleSubmit}>
      <input name="name" />
      {errors.name && <span>{errors.name}</span>}
      
      <input name="email" type="email" />
      {errors.email && <span>{errors.email}</span>}
      
      <input name="age" type="number" />
      {errors.age && <span>{errors.age}</span>}
      
      <button>Create User</button>
    </form>
  );
}
```

### Layer 2: Next.js Server Actions

Validate server-side requests before processing:

```typescript
// app/actions.ts
'use server'

import { UserSchema } from '@/lib/schemas/user';
import { createUser } from '@/lib/server/users';
import { revalidatePath } from 'next/cache';

export async function createUserAction(formData: FormData) {
  // Server-side validation (prevents malicious requests)
  const result = UserSchema.safeParse({
    id: crypto.randomUUID(),
    name: formData.get('name'),
    email: formData.get('email'),
    age: Number(formData.get('age')),
  });
  
  if (!result.success) {
    return { 
      error: true, 
      message: result.error.errors[0].message 
    };
  }
  
  // Data is validated, create user
  await createUser(result.data);
  revalidatePath('/users');
  
  return { success: true };
}
```

### Layer 3: SwallowKit Generated CRUD Operations

SwallowKit's `scaffold` command automatically generates type-safe CRUD operations that validate against your Zod schemas:

```typescript
// Generated by: npx swallowkit scaffold lib/models/user.ts
// app/api/user/route.ts (Next.js BFF API)
import { NextRequest, NextResponse } from 'next/server';
import { UserSchema } from '@/lib/models/user';

const FUNCTIONS_BASE_URL = process.env.FUNCTIONS_BASE_URL || 'http://localhost:7071';

export async function POST(request: NextRequest) {
  const body = await request.json();
  
  // Validate with Zod schema before forwarding to Azure Functions
  const result = UserSchema.safeParse(body);
  
  if (!result.success) {
    return NextResponse.json(
      { error: result.error.errors[0].message },
      { status: 400 }
    );
  }
  
  // Forward validated data to Azure Functions
  const response = await fetch(`${FUNCTIONS_BASE_URL}/api/user`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(result.data),
  });
  
  const data = await response.json();
  return NextResponse.json(data);
}
```

üìö **Learn more**: See the **[Scaffold Guide](./scaffold-guide.md)** for complete examples of generated CRUD code, including Azure Functions, API routes, and UI components.

### Layer 4: Azure Functions with Cosmos DB

Share the same schema in your independent backend:

```typescript
// Generated by: npx swallowkit scaffold lib/models/user.ts
// functions/src/user.ts (Azure Functions)
import { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';
import { UserSchema } from './models/user';
import { CosmosClient } from '@azure/cosmos';

const cosmosClient = new CosmosClient(process.env.CosmosDBConnection!);
const database = cosmosClient.database('MyDatabase');
const container = database.container('Users');

export async function createUser(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
  const body = await request.json();
  
  // Validate request with shared Zod schema
  const result = UserSchema.safeParse(body);
  
  if (!result.success) {
    return {
      status: 400,
      jsonBody: { error: result.error.errors[0].message }
    };
  }
  
  // Save validated data to Cosmos DB
  const { resource: created } = await container.items.create(result.data);
  
  return {
    status: 201,
    jsonBody: created
  };
}

app.http('createUser', {
  methods: ['POST'],
  authLevel: 'anonymous',
  handler: createUser
});
```

üìö **See it in action**: The **[Scaffold Guide](./scaffold-guide.md)** shows complete examples of generated Azure Functions with Cosmos DB integration.

## Advanced Patterns

### Partial Schemas

Validate only specific fields for updates:

```typescript
// Only validate name and email for profile updates
const UpdateProfileSchema = UserSchema.pick({ 
  name: true, 
  email: true 
});

export async function updateProfile(userId: string, data: FormData) {
  const result = UpdateProfileSchema.safeParse({
    name: data.get('name'),
    email: data.get('email'),
  });
  
  if (!result.success) {
    return { error: result.error.errors[0].message };
  }
  
  await userRepo.update({ id: userId, ...result.data });
}
```

### Nested Schemas

Compose complex data structures:

```typescript
const AddressSchema = z.object({
  street: z.string(),
  city: z.string(),
  postalCode: z.string(),
});

const UserWithAddressSchema = UserSchema.extend({
  address: AddressSchema,
});

export type UserWithAddress = z.infer<typeof UserWithAddressSchema>;
```

### Custom Validation

Add business logic validation:

```typescript
const ProductSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.number().positive(),
  discount: z.number().min(0).max(100),
}).refine(
  (data) => {
    // Custom validation: discounted price must be positive
    const finalPrice = data.price * (1 - data.discount / 100);
    return finalPrice > 0;
  },
  { message: 'Discounted price must be greater than 0' }
);
```

### Transformations

Transform data during validation:

```typescript
const UserInputSchema = z.object({
  name: z.string().trim().toLowerCase(), // Normalize name
  email: z.string().email().toLowerCase(), // Normalize email
  age: z.string().transform(Number), // Convert string to number
});
```

## Best Practices

### 1. Model File Structure

Follow SwallowKit's recommended structure for model files:

```typescript
// lib/models/user.ts
import { z } from 'zod';

// 1. Define the Zod schema
export const UserSchema = z.object({
  id: z.string(),
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Invalid email'),
  age: z.number().min(18, 'Must be 18 or older'),
  createdAt: z.date().default(() => new Date()),
});

// 2. Export the TypeScript type
export type User = z.infer<typeof UserSchema>;
```

üí° **SwallowKit Convention**: Name your schema with `Schema` suffix (e.g., `UserSchema`, `ProductSchema`) for automatic detection by the `scaffold` command.

### 2. Use safeParse() for Error Handling

```typescript
// ‚úÖ Good: Handle errors gracefully
const result = UserSchema.safeParse(data);
if (!result.success) {
  console.error(result.error.errors);
  return { error: 'Validation failed' };
}

// ‚ùå Bad: Throws exception
const user = UserSchema.parse(data); // Can throw!
```

### 3. Validation Messages for Better UX

Provide clear, user-friendly error messages:

```typescript
const ProductSchema = z.object({
  name: z.string().min(1, 'Product name is required'),
  price: z.number().positive('Price must be greater than 0'),
  category: z.enum(['electronics', 'clothing', 'books'], {
    errorMap: () => ({ message: 'Please select a valid category' })
  }),
});
```

### 4. Default Values and Optional Fields

```typescript
const TodoSchema = z.object({
  id: z.string(),
  title: z.string().min(1, 'Title is required'),
  completed: z.boolean().default(false), // Default value
  description: z.string().optional(), // Optional field
  createdAt: z.date().default(() => new Date()),
});
```

SwallowKit's scaffold command automatically generates appropriate UI:
- Optional fields are not marked as required in forms
- Default values are pre-populated
- Date fields get date pickers

üìö **Learn more**: See **[Type-Appropriate UI Generation](./scaffold-guide.md#type-appropriate-ui-generation)** in the Scaffold Guide.

### 5. Foreign Key Naming Convention

For automatic foreign key detection in SwallowKit:

```typescript
const TodoSchema = z.object({
  id: z.string(),
  categoryId: z.string().min(1, 'Category is required'), // Detected as FK to Category
  userId: z.string().min(1, 'User is required'), // Detected as FK to User
});
```

**Pattern**: `<ModelName>Id` ‚Üí References `<ModelName>` model

üìö **Learn more**: See **[Foreign Key Relationships](./scaffold-guide.md#foreign-key-relationships)** in the Scaffold Guide.

## Comparison with Other Approaches

### vs. Manual Type Definitions

```typescript
// ‚ùå Manual approach (error-prone)
interface User {
  id: string;
  name: string;
  email: string;
}

function validateUser(data: any): User {
  if (!data.id || !data.name || !data.email) {
    throw new Error('Invalid user');
  }
  if (!/\S+@\S+\.\S+/.test(data.email)) {
    throw new Error('Invalid email');
  }
  return data;
}

// ‚úÖ Zod approach (type-safe, declarative)
const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

type User = z.infer<typeof UserSchema>;
```

### vs. ORM Schemas

```typescript
// ‚ùå ORM-specific (locked to one library)
// Prisma example
model User {
  id    String @id
  name  String
  email String @unique
}

// ‚úÖ Zod (library-agnostic, portable)
const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

// Can be used with any database/ORM
```

## Migration Guide

### From Existing TypeScript Types

```typescript
// Before
interface User {
  id: string;
  name: string;
  email: string;
}

// After
const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

type User = z.infer<typeof UserSchema>;
```

üí° **Next Step**: Once you've migrated to Zod, use SwallowKit's `scaffold` command to automatically generate CRUD operations. See the **[Scaffold Guide](./scaffold-guide.md)**.

## Summary

Zod Schema Sharing in SwallowKit provides:

‚úÖ **Single Source of Truth** - Define once, use everywhere  
‚úÖ **Type Safety** - Compile-time and runtime validation  
‚úÖ **Consistency** - Same validation logic across all layers  
‚úÖ **Developer Experience** - IntelliSense, auto-completion, error messages  
‚úÖ **Maintainability** - Change schema once, updates everywhere  

This approach eliminates type drift, reduces bugs, and improves developer productivity across your entire stack.

## Next Steps

- **[Scaffold Guide](./scaffold-guide.md)** - Generate complete CRUD operations from your Zod schemas
- **[Zod Documentation](https://zod.dev/)** - Learn advanced Zod features and patterns
- **[README](../README.md)** - Get started with SwallowKit
