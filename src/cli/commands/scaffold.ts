/**
 * SwallowKit Scaffold ã‚³ãƒãƒ³ãƒ‰
 * Zod ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰ Azure Functions ã¨ Next.js BFF ã® CRUD ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
 */

import * as fs from "fs";
import * as path from "path";
import { parseModelFile, toKebabCase, toPascalCase } from "../../core/scaffold/model-parser";
import { generateAzureFunctionsCRUD } from "../../core/scaffold/functions-generator";
import { generateNextjsBFFRoutes } from "../../core/scaffold/nextjs-generator";
import {
  generateListPage,
  generateDetailPage,
  generateFormComponent,
  generateNewPage,
  generateEditPage,
} from "../../core/scaffold/ui-generator";

interface ScaffoldOptions {
  model: string; // ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ï¼ˆä¾‹: "lib/models/todo.ts" or "todo"ï¼‰
  functionsDir?: string; // Azure Functions ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "functions"ï¼‰
  apiDir?: string; // Next.js API routes ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "app/api"ï¼‰
  apiOnly?: boolean; // true ã®å ´åˆã€UI ã‚’ç”Ÿæˆã—ãªã„ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: falseï¼‰
}

export async function scaffoldCommand(options: ScaffoldOptions) {
  console.log("ğŸ—ï¸  SwallowKit Scaffold: Generating CRUD operations...\n");

  try {
    // 1. Resolve model file path
    const modelPath = resolveModelPath(options.model);
    console.log(`ğŸ“„ Model file: ${modelPath}`);

    // 2. Parse model file
    console.log("ğŸ” Parsing model file...");
    const modelInfo = await parseModelFile(modelPath);
    console.log(`âœ… Model parsed: ${modelInfo.name} (${modelInfo.schemaName})`);

    // 3. Check for ID field
    if (!modelInfo.hasId) {
      console.warn(
        "âš ï¸  Warning: Model does not have an 'id' field. CRUD operations may not work correctly."
      );
    }

    // 4. Copy model file to Functions
    const functionsDir = options.functionsDir || "functions";
    await copyModelToFunctions(modelInfo, functionsDir);

    // 5. Generate Azure Functions code
    await generateFunctionsCode(modelInfo, functionsDir);

    // 6. Generate Next.js BFF API Routes
    const apiDir = options.apiDir || "app/api";
    await generateBFFRoutes(modelInfo, apiDir);

    // 7. Generate UI components (unless --api-only)
    if (!options.apiOnly) {
      await generateUIComponents(modelInfo);
      await updateNavigationMenu(modelInfo);
    }

    console.log("\nâœ… Scaffold completed successfully!");
    console.log("\nğŸ“ Next steps:");
    console.log(
      `  1. Review generated files in ${functionsDir}/src/ and ${apiDir}/`
    );
    if (!options.apiOnly) {
      console.log(`  2. Check the generated UI pages in app/${toKebabCase(modelInfo.name)}/`);
      console.log("  3. Navigate to the model from the homepage menu");
    }
    console.log(
      `  ${options.apiOnly ? '2' : '4'}. Ensure FUNCTIONS_BASE_URL is set in your .env.local file`
    );
    console.log(
      `  ${options.apiOnly ? '3' : '5'}. Configure CosmosDBConnection in functions/local.settings.json`
    );
    console.log(`  ${options.apiOnly ? '4' : '6'}. Run 'npx swallowkit dev' to test the generated code`);
  } catch (error: any) {
    console.error("\nâŒ Scaffold failed:", error.message);
    process.exit(1);
  }
}

/**
 * ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è§£æ±º
 */
function resolveModelPath(modelInput: string): string {
  const cwd = process.cwd();

  // çµ¶å¯¾ãƒ‘ã‚¹ã®å ´åˆ
  if (path.isAbsolute(modelInput)) {
    return modelInput;
  }

  // æ‹¡å¼µå­ãŒã‚ã‚‹å ´åˆï¼ˆç›¸å¯¾ãƒ‘ã‚¹ï¼‰
  if (modelInput.endsWith(".ts")) {
    const fullPath = path.join(cwd, modelInput);
    if (fs.existsSync(fullPath)) {
      return fullPath;
    }
  }

  // æ‹¡å¼µå­ãŒãªã„å ´åˆã€lib/models/ ã§æ¢ã™
  const defaultPath = path.join(cwd, "lib", "models", `${modelInput}.ts`);
  if (fs.existsSync(defaultPath)) {
    return defaultPath;
  }

  // src/models/ ã§ã‚‚æ¢ã™
  const srcPath = path.join(cwd, "src", "models", `${modelInput}.ts`);
  if (fs.existsSync(srcPath)) {
    return srcPath;
  }

  // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
  throw new Error(
    `Model file not found: ${modelInput}\n` +
      `  Tried:\n` +
      `    - ${modelInput}\n` +
      `    - ${defaultPath}\n` +
      `    - ${srcPath}\n` +
      `  Please specify a valid model file path.`
  );
}

/**
 * Copy model file to Functions directory
 */
async function copyModelToFunctions(
  modelInfo: any,
  functionsDir: string
): Promise<void> {
  console.log("\nğŸ“‹ Copying model file to Functions...");

  const modelKebab = toKebabCase(modelInfo.name);
  const functionsModelsDir = path.join(
    process.cwd(),
    functionsDir,
    "src",
    "models"
  );

  // Create models directory
  if (!fs.existsSync(functionsModelsDir)) {
    fs.mkdirSync(functionsModelsDir, { recursive: true });
  }

  // Read original model file
  const originalContent = fs.readFileSync(modelInfo.filePath, "utf-8");

  // Add warning comment at the top
  const warning = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * 
 * This file is automatically generated from the model in lib/models/${modelKebab}.ts
 * To update this model, modify the original file and run:
 *   npx swallowkit scaffold ${modelKebab}
 * 
 * Any manual changes to this file will be overwritten.
 */

`;

  const modifiedContent = warning + originalContent;

  // Write to Functions models directory
  const targetPath = path.join(functionsModelsDir, `${modelKebab}.ts`);
  fs.writeFileSync(targetPath, modifiedContent, "utf-8");

  console.log(`âœ… Copied: ${targetPath}`);
}

/**
 * Generate Azure Functions CRUD code
 */
async function generateFunctionsCode(
  modelInfo: any,
  functionsDir: string
): Promise<void> {
  console.log("\nğŸ”¨ Generating Azure Functions CRUD code...");

  const modelKebab = toKebabCase(modelInfo.name);
  const functionFilePath = path.join(
    process.cwd(),
    functionsDir,
    "src",
    `${modelKebab}.ts`
  );

  // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
  const functionDir = path.dirname(functionFilePath);
  if (!fs.existsSync(functionDir)) {
    fs.mkdirSync(functionDir, { recursive: true });
  }

  // ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
  const code = generateAzureFunctionsCRUD(modelInfo);

  // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
  fs.writeFileSync(functionFilePath, code, "utf-8");

  console.log(`âœ… Created: ${functionFilePath}`);
}

/**
 * Next.js BFF API Routes ã‚’ç”Ÿæˆ
 */
async function generateBFFRoutes(
  modelInfo: any,
  apiDir: string
): Promise<void> {
  console.log("\nğŸ”¨ Generating Next.js BFF API routes...");

  const modelKebab = toKebabCase(modelInfo.name);
  const modelCamel = modelInfo.name.charAt(0).toLowerCase() + modelInfo.name.slice(1);

  // List route: app/api/[model]/route.ts
  const listRoutePath = path.join(
    process.cwd(),
    apiDir,
    modelCamel,
    "route.ts"
  );

  // Detail route: app/api/[model]/[id]/route.ts
  const detailRoutePath = path.join(
    process.cwd(),
    apiDir,
    modelCamel,
    "[id]",
    "route.ts"
  );

  // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
  const listRouteDir = path.dirname(listRoutePath);
  const detailRouteDir = path.dirname(detailRoutePath);

  if (!fs.existsSync(listRouteDir)) {
    fs.mkdirSync(listRouteDir, { recursive: true });
  }

  if (!fs.existsSync(detailRouteDir)) {
    fs.mkdirSync(detailRouteDir, { recursive: true });
  }

  // ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
  const routes = generateNextjsBFFRoutes(modelInfo);

  // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
  fs.writeFileSync(listRoutePath, routes.listRoute, "utf-8");
  fs.writeFileSync(detailRoutePath, routes.detailRoute, "utf-8");

  console.log(`âœ… Created: ${listRoutePath}`);
  console.log(`âœ… Created: ${detailRoutePath}`);
}

/**
 * Generate UI components (list, detail, form, create, edit pages)
 */
async function generateUIComponents(modelInfo: any): Promise<void> {
  console.log("\nğŸ¨ Generating UI components...");

  const modelKebab = toKebabCase(modelInfo.name);
  const modelName = modelInfo.name;
  const cwd = process.cwd();

  // Create directory structure: app/[model]/
  const modelDir = path.join(cwd, "app", modelKebab);
  const componentsDir = path.join(modelDir, "_components");
  const newDir = path.join(modelDir, "new");
  const idDir = path.join(modelDir, "[id]");
  const editDir = path.join(idDir, "edit");

  // Create directories
  [componentsDir, newDir, editDir].forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });

  // Generate and write files
  const listPage = generateListPage(modelInfo);
  const detailPage = generateDetailPage(modelInfo);
  const formComponent = generateFormComponent(modelInfo);
  const newPage = generateNewPage(modelInfo);
  const editPage = generateEditPage(modelInfo);

  fs.writeFileSync(path.join(modelDir, "page.tsx"), listPage, "utf-8");
  fs.writeFileSync(path.join(idDir, "page.tsx"), detailPage, "utf-8");
  fs.writeFileSync(path.join(componentsDir, `${modelName}Form.tsx`), formComponent, "utf-8");
  fs.writeFileSync(path.join(newDir, "page.tsx"), newPage, "utf-8");
  fs.writeFileSync(path.join(editDir, "page.tsx"), editPage, "utf-8");

  console.log(`âœ… Created: ${path.join(modelDir, "page.tsx")}`);
  console.log(`âœ… Created: ${path.join(idDir, "page.tsx")}`);
  console.log(`âœ… Created: ${path.join(componentsDir, `${modelName}Form.tsx`)}`);
  console.log(`âœ… Created: ${path.join(newDir, "page.tsx")}`);
  console.log(`âœ… Created: ${path.join(editDir, "page.tsx")}`);
}

/**
 * Update navigation menu on the homepage
 */
async function updateNavigationMenu(modelInfo: any): Promise<void> {
  console.log("\nğŸ“‹ Updating navigation menu...");

  const modelKebab = toKebabCase(modelInfo.name);
  const cwd = process.cwd();

  // Read or create scaffold config
  const configPath = path.join(cwd, ".swallowkit", "scaffold.json");
  const configDir = path.dirname(configPath);

  if (!fs.existsSync(configDir)) {
    fs.mkdirSync(configDir, { recursive: true });
  }

  let config: { models: Array<{ name: string; path: string; label: string }> } = { models: [] };

  if (fs.existsSync(configPath)) {
    config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
  }

  // Add model to config if not already present
  if (!config.models.find(m => m.name === modelInfo.name)) {
    config.models.push({
      name: modelInfo.name,
      path: `/${modelKebab}`,
      label: modelInfo.name,
    });

    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), "utf-8");
    console.log(`âœ… Added ${modelInfo.name} to navigation menu`);
  } else {
    console.log(`â„¹ï¸  ${modelInfo.name} already in navigation menu`);
  }

  // Update homepage to include menu
  const homePagePath = path.join(cwd, "app", "page.tsx");
  
  if (fs.existsSync(homePagePath)) {
    let homePageContent = fs.readFileSync(homePagePath, "utf-8");
    
    // Check if menu component is already added
    if (!homePageContent.includes('scaffoldedModels')) {
      // Add import and menu section
      const menuImport = `import { scaffoldConfig } from '@/lib/scaffold-config';\n`;
      const menuSection = `
      {/* Scaffolded Models Menu */}
      {scaffoldConfig.models.length > 0 && (
        <div className="mt-8">
          <h2 className="text-3xl font-bold mb-6 text-gray-900 dark:text-gray-100">Models</h2>
          <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
            {scaffoldConfig.models.map((model) => (
              <a
                key={model.name}
                href={model.path}
                className="block p-6 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
              >
                <h3 className="text-xl font-semibold mb-2 text-gray-900 dark:text-gray-100">{model.label}</h3>
                <p className="text-gray-600 dark:text-gray-400">Manage {model.label.toLowerCase()}</p>
              </a>
            ))}
          </div>
        </div>
      )}`;

      // Insert import at the beginning
      if (!homePageContent.includes(menuImport.trim())) {
        homePageContent = menuImport + homePageContent;
      }

      // Insert menu section before the closing div of main content
      if (!homePageContent.includes('Scaffolded Models Menu')) {
        // Find the last </div> or end of main section
        const mainEndIndex = homePageContent.lastIndexOf('</div>');
        if (mainEndIndex !== -1) {
          homePageContent = 
            homePageContent.slice(0, mainEndIndex) +
            menuSection +
            '\n' +
            homePageContent.slice(mainEndIndex);
        }
      }

      fs.writeFileSync(homePagePath, homePageContent, "utf-8");
      console.log(`âœ… Updated homepage menu`);
    } else {
      console.log(`â„¹ï¸  Homepage menu already configured`);
    }
  }
}
